## LEGB规则中的global全局变量的使用说明
* 定义全局变量
如果在后续函数中只是访问模块内全局变量的值，不对全局变量进行赋值的时候，直接在函数体外定义的变量就是模块内的全局变量
```
方法一
>>>global x 
>>>x = 3
>>>def glprint():
>>>  abc = x
>>>  print(abc)
>>>  
>>>glprint()
3
方法二
>>>x = 3
>>>def glprint():
>>>  abc = x
>>>  print(abc)
>>>  
>>>glprint()
3
```
* 如果只是单纯定义一个全局变量名称，还没有对全局变量进行赋值，如果要在函数中启用这个全局变量，就必须先对其赋值，
* 要对全局变量进行赋值就要明确告诉编译器，这个变量名是全局变量，也就是在全局变量名前加global关键字，然后进行赋值操作
```
>>>global x 
>>>def glprint():
>>>  global x
>>>  x = 3
>>>  print(abc)
>>>  
>>>glprint()
>>>print(x)
3
3
```
* 为什么只是需要在对全局变量赋值的时候，需要在函数体内用关键字global声明后面这个变量是指的全局变量那个。
因为python中对变量的创建、定义和赋值都可以通过=来进行，当你在函数体内定义一个跟全局变量一样的变量名的时候，
编译器会判断你此时是生成了一个新的变量，只不过碰巧跟一个全局变量的名称相同罢了(这里解释器会认为是有歧义的)，
这个跟全局变量相同的变量在函数体内只是一个局部变量，你在函数体内对其赋值操作并不会影响到全局变量的值，
所以如果你想对全局变量进行赋值，就必须用在函数体内用global声明这个变量名称对应的是那个全局变量，
后续的变量赋值才会直接改变全局变量的值。
总结:像一些普通的数据类型int str float 的全局变量在函数中赋值操作时候由于等号 = 赋值操作跟创建、定义新的变量操作有歧义
所以对全局变量进行赋值操作的时候需要声明global

* 为什么像dict、list等类型的数据类型的赋值操作不需要声明global
```
>>>s = 'foo'
>>>d = {'a':1} 
>>>def f(): 
>>>  s = 'bar'
>>>  d['b'] = 2
>>>f() 
>>>print s 
>>>print d 
'foo'
{'a':1,'b':2} 
```
因为字典、序列的等号赋值操作不会跟创建新的变量操作冲突呀！！！，因为没有歧义，所以解释器自然会认为你是在给全局变量d中的key为b的键赋值为2

注意：如果在函数体外并没有定义变量，你在函数体内不加global定义的变量永远只能是局部变量，生命周期只能是函数体内。

## 如何在不同模块中使用全局变量
思路是单独启用一个全局变量模块中转数据！
例如:
