## str()和repr()函数区别
* str()输出的是给用户看的，repr()输出的是给解释器看的
* repr()结果通过eval()可以再返回成原对象
* 对于对人类并没有特别的表示形式的对象,str()和repr()将返回相同的值
```
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> print(s)
Hello, world.
>>> str(1.0/7.0)
'0.14285714285714285'
>>> repr(1.0/7.0)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print s
The value of x is 32.5, and y is 40000...
>>> # The repr() of a string adds string quotes and backslashes:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hello)
'hello, world'

>>> print(hellos)
'hello, world\n'
>>> # The argument to repr() may be any Python object:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
```
* str()、repr()的rjust(),ljust(),center()方法
> 它通过在左侧填充空格使字符串在给定宽度的
列右对齐。类似的方法还有str.ljust()和str.center()。这些方法不会输出任何内容，它们只返回
新的字符串。如果输入的字符串太长，它们不会截断字符串，而是保持原样返回；这会使列
的格式变得混乱，但是通常好于另外一种选择，那可能是一个错误的值。（如果你真的想要
截断，可以加上一个切片操作，例如x.ljust(n)[:n]。)

* 另外一种方法 str.zfill()，它向数值字符串左侧填充零。该函数可以正确识别正负号：
```
>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
```
## str.format()用法
* 基本用法
```
>>> print 'We are the {} who say "{}!"'.format('knights', 'Ni')
We are the knights who say "Ni!"
```
这里用两种方法输出平方和立方表：

```
>>> for x in range(1, 11):
... print repr(x).rjust(2), repr(x*x).rjust(3),
... # Note trailing comma on previous line
... print repr(x*x*x).rjust(4)
...
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
>>> for x in range(1,11):
... print '{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x)
...
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
```
>这里面：{0:2d} 表示第一个参数x的格式。0 代表x,:2d 表示两个宽度的10进制数显示。
        {1:3d} 表示第一个参数x*x的格式。1 代表x*x,:3d 表示三个宽度的10进制数显示。
        {2:4d} 表示第一个参数x*x*x的格式。2代表x*x*x,:4d 表示四个宽度的10进制数显示。
        
* 以下是常用方法
```
* 通过位置
print '{0},{1}'.format('chuhao',20)

print '{},{}'.format('chuhao',20)

print '{1},{0},{1}'.format('chuhao',20)

* 通过关键字参数
print '{name},{age}'.format(age=18,name='chuhao')

class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def __str__(self):
        return 'This guy is {self.name},is {self.age} old'.format(self=self)

print str(Person('chuhao',18))

* 通过映射 list
a_list = ['chuhao',20,'china']
print 'my name is {0[0]},from {0[2]},age is {0[1]}'.format(a_list)
#my name is chuhao,from china,age is 20

* 通过映射 dict
b_dict = {'name':'chuhao','age':20,'province':'shanxi'}
print 'my name is {name}, age is {age},from {province}'.format(**b_dict)
#my name is chuhao, age is 20,from shanxi

* 填充与对齐
print '{:>8}'.format('189')
#     189
print '{:0>8}'.format('189')
#00000189
print '{:a>8}'.format('189')
#aaaaa189

* 精度与类型f
* 保留两位小数
print '{:.2f}'.format(321.33345)
* 321.33

* 用来做金额的千位分隔符
print '{:,}'.format(1234567890)
#1,234,567,890

* 其他类型 主要就是进制了，b、d、o、x分别是二进制、十进制、八进制、十六进制。

print '{:b}'.format(18) #二进制 10010
print '{:d}'.format(18) #十进制 18
print '{:o}'.format(18) #八进制 22
print '{:x}'.format(18) #十六进制12
```


* pprint模块
>提供更复杂的打印控制，以解释器可读的方式打印出内置对象和用户定义的对象。
当结果超过一行时，这个"漂亮的打印机"将添加分行符和缩进，以更清楚地显示数据结构：
```
>>> import pprint
>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
... 'yellow'], 'blue']]]
...
>>> pprint.pprint(t, width=30)
[[[['black', 'cyan'],
'white',
['green', 'red']],
[['magenta', 'yellow'],
'blue']]]
```
* textwrap模块
>格式化文本段落以适应设定的屏宽：
```
>>> import textwrap
>>> doc = """The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines."""
...
>>> print textwrap.fill(doc, width=40)
The wrap() method is just like fill()
except that it returns a list of strings
instead of one big string with newlines
to separate the wrapped lines.
```
* locale模块
>什么是locale
locale 这个单词中文翻译成地区或者地域，其实这个单词包含的意义要宽泛很多。locale 是根据计算机用户所使用的语言，所在国家或者地区，以及当地的文化传统所定义的一个软件运行时的语言环境。通常情况下它可以按照涉及使用习惯分为12大类:

- 语言符号及其分类（LC_CTYPE)
- 数字（LC_NUMBERIC）
- 比较习惯（LC_COLLATE)
- 时间显示格式（LC_TIME）
- 货币单位（LC_MONETARY)
- 信息主要是提示信息，错误信息，状态信息，标题，标签，按钮和菜单等（LC_MESSAGES）
- 行么书写方式（LC_NAME）
- 地址书写方式（LC_ADDRESS）
- 电话号码书写方式（LC_TELEPHONE）
-度量衡表达方式（LC_MEASUREMENT）
- 默认纸张尺寸大小（LC_PAPER）
- 对locale 自身包含信息的概述（LC_IDENTIFICATION）
- 除此之外还有一个LANGUAGE参数，它与LC_MESSAGES相似

```
>>> import locale
>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
'English_United States.1252'
>>> conv = locale.localeconv() # get a mapping of conventions
>>> x = 1234567.8
>>> locale.format("%d", x, grouping=True)
'1,234,567'
>>> locale.format_string("%s%.*f", (conv['currency_symbol'],
... conv['frac_digits'], x), grouping=True)
'$1,234,567.80'
```
```
import locale

# 返回当前环境locale categorg相关的设定，category默认为 LC_CTYPE
# LC_CTYPE 决定字符处理函数相关行为，比如 string 函数
locale.getlocale([category])


# 尝试判断默认的locale设置，并且以元组的形式返回(language code, encoding)
locale.getdefaultlocale([envvars])


# 修改locale category 的设定为 locale的值， 比如locale.setlocale(locale.LC_ALL, 'C'),  C 代表去除所有本地化设置
# 如果第二个参数locale没有提供，那么会返回category的设置
locale.setlocale(category[, locale])


# 很多程序会像下面这样开头，这样做会将所有的locale设置成用户默认的设置（通常是环境变量LANF的值）。
# 但setlocale() 不能在所有系统上保证线程安全性，这点要注意
import locale
locale.setlocale(locale.LC_ALL, '')
```
