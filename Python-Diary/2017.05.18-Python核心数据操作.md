###  2017.5.18-Python核心数据操作

* 字符编码问题：

  注意”字符”和”字节”两个术语的不同，“字节”是一个8位的物理存贮单元，
  
  而“字符”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。
  
  首先用类库sys获取默认文件编码模式
```  
  import sys
  print sys.getdefualtencoding() _#一般编码模式为Ascii、UTF-8
```
  如果要修改系统默认编码模式
```
  reload(sys)
  setdefualtencoding('UTF-16')
```  
* 使用=号赋值一个字符对象给变量的时候，字符的编码方式如果不特殊制定，则找defualtencoding编码方式编码
```
  str1="字符串" _#字符串  按照系统文件默认编码方式编码
```

* 这两个作用不一样,
  ```
  # coding:utf-8
  ```
  作用是定义源代码的编码. 如果没有定义, 此源码中是不可以包含中文字符串的.例如你源码文件中有中文注释就必须要在开头注明
 ```
 sys.getdefaultencoding()
 ```
  是设置默认的string的编码格式

* 在Python2.x中 defaultencoding是ascii，
  所以如果你不修改 defaultencoding为UTF-8或者UTF-16或其他，
  那么你在后续代码中需要对字符进行编码得时候就会出现错误
  
                            在2.x环境中，defaultencoding是ascii
  ```
  # -*- coding: utf-8 -*-      源代码中有中文字符所以需要在开头注明文件源码的格式为UTF-8
  
  s="苦短"
  
  s.encode('gbk')              此处相当于对字符进行了 s.decode("ascii").encode("gbk"),
                               对ascii解码是会报错的，因为ascii已经是表                              
                               明编码了不能进行再解码
  ```
 
 
 
## 重点总结
  
* python 3和2很大区别就是python本身改为默认用unicode编码。

    字符串不再区分"abc"和u"abc", 字符串"abc"默认就是unicode，不再代表本地编码、
    
    python 3中只有unicode str，所以把decode方法去掉了
    
    
* 在Python3中， ++以字节形式++ 表示的字符串则必须加上前缀b，也就是写成上文的b'xxxx'形式。
  
    \x表示后面是十六进制， \xe4\xb8\xad即是二进制的 11100100 10111000 10101101
    
     ```
     b'\xe4\xb8\xad'.decode('utf-8')     ___'中'
     ```
* 在Python2.x中 一个程序一共涉及到3个解码编码的地方

  
### 1.程序文件.py文件保存的时候可以选择以何种编码格式保存(UTF-8/UTF-16/GBK等)
* 需要注意的是,源文件的编码格式一定要个文件开头声明的解码格式一致，例如
    一下文件是以GBK编码保存的
  ```
  #coding:uft-8 
  s = u"中国"    
  ```
    当打开文件运行到s =u"中国"的时候
### 2.文件开头声明解码方式
  ```
      # coding:UTF-8
  ```
### 3.程序内，例如函数内对字符进行编码解码操作
  ```
      str1=u"测试字符串"  
  ```
  
  所有带引号的 字符串 赋值，该字符串都是unicode类型字符，
  
  如果导入文件中的字符不是以unicode 形式保存的，则以比特流形式读取出来

---
  
# Unicode和utf-8、utf-16相关重点

* ### Unicode详细介绍

* 1.容易产生后歧义的两字节
  unicode的第一个版本是用两个字节(16bit)来表示所有字符

  实际上这么说容易让人产生歧义,我们总觉得两个字节就代表保存在计算机中时是两个字节.于是任何字符如果用unicode表示的话保存下来都占两个字节.其实这种说法是错误的.

  其实Unicode涉及到两个步骤,首先是定义一个规范,给所有的字符指定一个唯一对应的数字,这完全是数学问题,可以跟计算机没半毛钱关系.第二步才是怎么把字符对应的数字保存在计算机中,这才涉及到实际在计算机中占多少字节空间.

  所以我们也可以这样理解,Unicode是用0至65535之间的数字来表示所有字符.其中0至127这128个数字表示的字符仍然跟ASCII完全一样.65536是2的16次方.这是第一步.第二步就是怎么把0至65535这些数字转化成01串保存到计算机中.这肯定就有不同的保存方式了.于是出现了UTF(unicode transformation format),有UTF-8,UTF-16.

* 2.UTF-8 与UTF-16的区别

  UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.

  于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定.

  于是UTF-8和UTF-16的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用UTF-8就比UTF-16节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16就占优势了,可以节省很多空间.另外还有个容错问题,等会再讲

  看的有点晕了吧,举个例子.假如中文字"汉"对应的unicode是6C49(这是用十六进制表示,用十进制表示是27721为啥不用十进制表示呢?很明显用十六进制表示要短点.其实都是等价的没啥不一样.就跟你说60分钟和1小时一样.).你可能会问当用程序打开一个文件时我们怎么知道那是用的UTF-8还是UTF-16啊.自然会有点啥标志,在文件的开头几个字节就是标志.

  EF BB BF 表示UTF-8

  FE FF 表示UTF-16.

* 用UTF-16表示"汉"

  假如用UTF-16表示的话就是01101100   01001001(共16 bit,两个字节).程序解析的时候知道是UTF-16就把两个字节当成一个单元来解析.这个很   简单.

* 用UTF-8表示"汉"

  用UTF-8就有复杂点.因为此时程序是把一个字节一个字节的来读取,然后再根据字节中开头的bit标志来识别是该把1个还是两个或三个字节做为一个   单元来处理.

  0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样.

  110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元

  1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元.

  这是约定的规则.你用UTF-8来表示时必须遵守这样的规则.我们知道UTF-16不需要用啥字符来做标志,所以两字节也就是2的16次能表示65536个字符.

  而UTF-8由于里面有额外的标志信息,所有一个字节只能表示2的7次方128个字符,两个字节只能表示2的11次方2048个字符.而三个字节能表示2的16次   方,65536个字符.

  由于"汉"的编码27721大于2048了所有两个字节还不够,只能用三个字节来表示.

  所有要用1110xxxx 10xxxxxx 10xxxxxx这种格式.把27721对应的二进制从左到右填充XXX符号(实际上不一定从左到右,也可以从右到左,这是涉及到另外一个问题.等会说.

  刚说到填充方式可以不一样,于是就出现了Big-Endian,Little-Endian的术语.Big-Endian就是从左到右,Little-Endian是从右到左.
  
* Big Endian和Little Endian
  一个字符可能占用多个字节，那么这多个字节在计算机中如何存储呢？比如字符0xABCD，它的存储格式到底是AB CD，还是CD AB 呢？实际上两者都有可能，并分别有不同的名字。如果存储为AB CD，则称为Big Endian；如果存储为 CD AB，则称为Little Endian。
  具体来说，以下这种存储格式为Big Endian，因为值(0xABCD)的高位(0xAB)存储在前面：
  地址                 值
  0x00000000     AB
  0x00000001     CD
  相反，以下这种存储格式为Little Endian：
  地址                 值
  0x00000000     CD
  0x00000001     AB

  由上面我们可以看出UTF-8需要判断每个字节中的开头标志信息,所以如果一当某个字节在传送过程中出错了,就会导致后面的字节也会解析出错.而UTF-16不会判断开头标志,即使错也只会错一个字符,所以容错能力强.

 

* Unicode版本2

  前面说的都是unicode的第一个版本.但65536显然不算太多的数字,用它来表示常用的字符是没一点问题.足够了,但如果加上很多特殊的就也不够了.于是从1996年开始又来了第二个版本.用四个字节表示所有字符.这样就出现了UTF-8,UTF16,UTF-32.原理和之前肯定是完全一样的,UTF-32就是把所有的字符都用32bit也就是4个字节来表示.然后UTF-8,UTF-16就视情况而定了.UTF-8可以选择1至8个字节中的任一个来表示.而UTF-16只能是选两字节或四字节..由于unicode版本2的原理完全是一样的,就不多说了.

  前面说了要知道具体是哪种编码方式,需要判断文本开头的标志,下面是所有编码对应的开头标志

  EF BB BF　　　 UTF-8
  FE FF　　　　　UTF-16/UCS-2, little endian
  FF FE　　　　　UTF-16/UCS-2, big endian
  FF FE 00 00　　UTF-32/UCS-4, little endian.
  00 00 FE FF　　UTF-32/UCS-4, big-endian.

  其中的UCS就是前面说的ISO制定的标准,和Unicode是完全一样的,只不过名字不一样.ucs-2对应utf-16,ucs-4对应UTF-32.UTF-8是没有对应的UCS
