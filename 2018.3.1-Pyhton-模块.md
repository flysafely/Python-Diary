## 模块导入的方式
* import modelName
>直接导入被 导入模块 名到 导入模块中的符号表中
通过调用modelName.itemName() 调用模块中的方法
```
>>> import fibo
```
>这不会直接把 fibo 中定义的函数的名字导入当前的符号表中；它只会把模块名字 fibo 导入其
中。你可以通过模块名访问这些函数：
```
>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
```
> 如果你打算频繁使用一个函数，可以将它赋给一个本地的变量：
```
>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
> 如果你觉得被导入的模块名不方便记忆或者名字过长，可以通过导入时候用as 给其重命名
```
>>>import fibo as fb
>>> fb.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
```
* from modelName import itemName
>import 语句的一个变体直接从被导入的模块中导入名字到导入模块的符号表中。例如：
```
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
>这不会把模块名导入到本地的符号表中（所以在本例中，fibo 将没有定义）。
还有种方式可以导入模块中定义的所有名字：
```
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
>这种方式不会导入以下划线 (_) 开头的名称。

>>注意:一般情况下不赞成从一个模块或包中导入'*'，因为这通常会导致代码很难读。不过，在
交互式会话中这样用是可以的，它可以让你少敲一些代码。

>>注意:每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，
你必需重新启动解释器 —— 或者，如果你就是想交互式的测试这么一个模块，可以使
用reload()，例如reload(modulename)。

## 执行模块

当你用下面的方式运行一个 Python 模块
```
python fibo.py <arguments>
```
模块中的代码将会被执行，就像导入它一样，不过此时 name 被设置为 "main" 。也就是说，
如果你在模块后加入如下代码:
```
if __name__ == "__main__":
import sys
fib(int(sys.argv[1]))
```
就可以让此文件既可以作为可执行的脚本，也可以当作可以导入的模块，因为解析命令行的
那部分代码只有在模块作为 “main” 文件执行时才被调用：
```
$ python fibo.py 50
1 1 2 3 5 8 13 21 34
```
如果模块是被导入的，将不会运行这段代码：
```
>>> import fibo
>>>
```
这种方法通常用来为模块提供一个方便的用户接口，或者用来测试（例如直接运行脚本会执
行一组测试用例）。
