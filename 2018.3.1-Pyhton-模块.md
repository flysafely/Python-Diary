## 模块导入的方式
* import modelName
>直接导入被 导入模块 名到 导入模块中的符号表中
通过调用modelName.itemName() 调用模块中的方法
```
>>> import fibo
```
>这不会直接把 fibo 中定义的函数的名字导入当前的符号表中；它只会把模块名字 fibo 导入其
中。你可以通过模块名访问这些函数：
```
>>> fibo.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
```
> 如果你打算频繁使用一个函数，可以将它赋给一个本地的变量：
```
>>> fib = fibo.fib
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
> 如果你觉得被导入的模块名不方便记忆或者名字过长，可以通过导入时候用as 给其重命名
```
>>>import fibo as fb
>>> fb.fib(1000)
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
```
* from modelName import itemName
>import 语句的一个变体直接从被导入的模块中导入名字到导入模块的符号表中。例如：
```
>>> from fibo import fib, fib2
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
>这不会把模块名导入到本地的符号表中（所以在本例中，fibo 将没有定义）。
还有种方式可以导入模块中定义的所有名字：
```
>>> from fibo import *
>>> fib(500)
1 1 2 3 5 8 13 21 34 55 89 144 233 377
```
>这种方式不会导入以下划线 (_) 开头的名称。

>>注意:一般情况下不赞成从一个模块或包中导入 * ，因为这通常会导致代码很难读。不过，在
交互式会话中这样用是可以的，它可以让你少敲一些代码。
>>注意:每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，
你必需重新启动解释器 —— 或者，如果你就是想交互式的测试这么一个模块，可以使
用reload()，例如reload(modulename)。
